[INCLUDE=presentation]
Title         : Explorando Modelos de Mapeamento Genético 
Sub Title     : Evolução no Porão
Author        : Diogo Melo
Affiliation   : LEM - USP
Email         : diogro@gmail.com
Reveal Theme  : solarized
Beamer Theme  : singapore
Package       : amsmath
Package       : setspace
Package       : mathptmx
Package       : stackengine
Package       : url
Transition    : linear
Locale        : pt_br


~ MathDefs 
\parskip 1em
\newcommand\stackequal[2]{%
  \mathrel{\stackunder[2pt]{\stackon[4pt]{=}{$\scriptscriptstyle#1$}}{%
  $\scriptscriptstyle#2$}}}
\def\useanchorwidth{F}
\def\mmh{{\hbox{-}}}
~ 

<script>
revealConfig.transition='linear';
</script>

[TITLE]

# Mapeamento de QTLs

Ligação entre genótipo de fenótipo

# Populações experimentais

~ Center
![](images/f2pop.png)
~

# Populações experimentais

~ Center
![](images/f2popQtl.png)
~
# QTLs via Anova

~ Center
![](images/anova_plot.png)
~
# Parametrizando via efeitos genéticos

![](images/centered_anova_plot.png)

# Modelos de regressão 

~ Center
![](images/ortogonal_regression_plot.png)
~

# Regressão básica

- Para o marcador $j$ 

~ Equation
E[y_i] = \mu +
a_j X_{ij}^a +
d_j X_{ij}^d
~

~ Equation
\begin{aligned}
X_{ij}^{a} &\in 
\begin{bmatrix} 
  1 & 0 & -1 
\end{bmatrix} \\
X_{ij}^{d} &\in 
\begin{bmatrix} 
  1 & 0
\end{bmatrix}
\end{aligned}
~

# Problema de LD

# Interval mapping

Incluimos marcadores antes e depois do marcador de interesse

~ Equation
\begin{aligned}
E[y_i] = & \mu + a_k X_{ij}^{a} + d_k X_{ij}^{d} + \\
&+ a_{j-1} X_{ij-1}^{a} + d_{j-1} X_{ij-1}^{d} + \\
&+ a_{j+1} X_{ij+1}^{a} + d_{j+1} X_{ij+1}^{d}
\end{aligned}
~

# Interval mapping permite mapementos mais precisos


# AIL e resolução de mapeamento

~ Center
![](images/f3pop.png)
~

# F3 tem estrutura familiar

~ Center
![](images/crosses.png){ width:800px }
~

# Modelos hierárquicos para a F3

- Para um indivíduo da familia $k$

~ Equation
E[y_i] = \mu + \beta_{k[i]} +
a_j X_{ij}^a +
d_j X_{ij}^d 
~

~ Equation
  \beta_k \sim Normal(0, G)
~

- {.fragment} Mesma coisa pra interval mapping
- {.fragment} Funciona, mas é muito lento

# Modelos megalomaníacos

- Será que podemos ajustar todos os marcadores ao mesmo tempo?

~ Equation
E[y_i] = \mu + \sum_{j=1}^p a_j X_{ij}^a + d_j X_{ij}^d
~

- {.fragment} Alta correlação entre os preditores causa um monte de problemas
- {.fragment} Muito ruido e over-fitting

# Modelos Megalomaníacos

~Center
![](images/mega_ML_fit.png)
~

# Notações equivalentes

~ Equation
E[y_i] = \mu + \sum_{j=1}^p a_j X_{ij}^a
~

~ Equation {.fragment}
    (\hat \mu, \{\hat a_j\}_{j=1}^p) \stackequal{}{argmin} \left \{ \sum_{i = 1}^n \left ( y_i - \mu - \sum_{j = 1}^p a_j X_{ij}^a \right )^2 \right \}
~ 

# Modelos penalizados

- Toda uma classe de modelos que tenta usar o fato que a maioria dos coeficientes é zero (nem todo marcador tem efeito fenotípico)

- {.fragment} The LASSO (least absolute shrinkage and selection operator)

~ Equation {.fragment}
    (\hat \mu, \{\hat a_j\}_{j=1}^p) \stackequal{}{argmin} \left \{ \sum_{i = 1}^n \left ( y_i - \mu - \sum_{j = 1}^p a_j X_{ij}^a \right )^2  
    +  \lambda \sum_{j=1}^p \|a_j\| \right \}
~ 

# Modelos penalizados

- Toda uma classe de modelos que tenta usar o fato que a maioria dos coeficientes é zero

- Ridge regression

~ Equation {.fragment}
    (\hat \mu, \{\hat a_j\}_{j=1}^p) \stackequal{}{argmin} \left \{ \sum_{i = 1}^N \left ( y_i - \mu - \sum_{j = 1}^p a_j X_{ij}^a \right )^2  
    +  \lambda \sum_{j=1}^p \|a_j\|^2 \right \}
~ 

# O estimador Lasso e Ridge

~ Center
![](images/lasso_ridge.png)
~

# Formulação Bayesiana do LASSO

~ Equation
E[y_i] = \mu + \sum_{j=1}^N a_j X_{ij}^a
~

~ Equation
P(a_j|\lambda, \sigma^2) = \prod_{j=1}^N \frac{\lambda}{2\sqrt{\sigma^2}} e^{-\lambda \|a_j\|/\sigma^2}
~

# Formulação Bayesiana é sempre bom

- Podemos usar amostradores para montar modelos mais complicados (Stan, JAGS, Bugs, PyMC...)
- Podemos incluir os termos necessários para AIL (F3 pra frente)
- Prior deixa explita nossa informação sobre a distribuição dos efeitos


~ Equation
E[y_i] = \mu + \beta_{k[i]} + \sum_{j=1}^N a_j X_{ij}^a
~

~ Equation
  \beta_k \sim Normal(0, G)
~

~ Equation
P(a_j|\lambda, \sigma^2) = \prod_{j=1}^N \frac{\lambda}{2\sqrt{\sigma^2}} e^{-\lambda \|a_j\|/\sigma^2}
~


# Lasso é legal, mas...

- Não tem nenhuma forma objetiva de fazer mapeamento
- Tende a escolher de forma meio arbitraria entre marcadores correlacionados (e encolher o resto pra zero)
- Todas as estimativas de efeitos tem pelo menos um pouco de shrinkage 

# Lasso e shrinkage

~ Center
![](images/lasso_shrink.png)
~

# Como estimar os efeitos precisamente e manter o shrinkage onde precisa?


# Modelos Penalizados Hierárquicos

- Ou: agora sim, vamos todos enlouquecer

- {.fragment} Solução óbvia na cabeça de um Bayesiano: vamos colocar um parâmetro de shrinkage por efeito estimado 

~ Center
Regra de ouro: "sempre que seu problema é muito complicado, talvez deixar ele mais complicado ajude" 
{.fragment; width: 18em; border: solid 1px black; \
  padding: 1ex; background-color: FloralWhite }
~


# Modelos Penalizados Hierárquicos

- Idéia geral:

~ Equation
E[y_i] = \mu + \sum_{j=1}^N a_j X_{ij}^a
~ 

~ Equation
\begin{aligned}
&P(a_j|\lambda_j) \\
&P(\lambda_j|\tau) \\
&P(\tau)
\end{aligned} 
~

# Hierarchical adaptive lasso (HAL)

~ Equation
\begin{aligned}
P(a_j|\lambda_j) &= Normal(0, \lambda^2) \\
P(\lambda_j|\tau) &= Gamma(1, \tau^2/2) \\
P(\tau) &= Inv\mmh Gamma(a, b)
\end{aligned} 
~

~Center
- $\lambda_j \rightarrow$ shrinkage local
- $\tau\rightarrow$ shrinkage global
~

# Lasso vs HAL

~ Center
![](images/lasso_HAL_shrink.png)
~

- Resolve o problema de shrinkage exagerado
- Não ajuda no mapeamento

# The Horseshoe

~ Equation
\begin{aligned}
P(a_j|\lambda_j) &= Normal(0, \lambda^2) \\
P(\lambda_j|\tau) &= Cauchy(1, \tau) \\
P(\tau) &= Cauchy(1, b) 
\end{aligned} 
~

~Center
- $\lambda_j \rightarrow$ shrinkage local
- $\tau\rightarrow$ shrinkage global
~

# Horseshoe e seleção de modelos

- Estimador dos coeficientes tem a forma:

~ Equation
\begin{aligned}
\hat a_j^{HC} &= w_ja_j^{ML} \\
P(w_j) &= Beta(0.5, 0.5)
\end{aligned} 
~

~Center
$w_j$ é um parâmetro de intensidade de shrinkage, ou, um __parâmetro de inclusão__
{.fragment; width: 18em; border: solid 1px black; \
  padding: 1ex; background-color: FloralWhite }
~

# Shrinkage Hierárquico Funciona mesmo

~ Center
![](images/all_fits.png)
~